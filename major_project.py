# -*- coding: utf-8 -*-
"""Major Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1U2lZ1kcfZQY3xwjcPuKtzgRucqBbj5W0

#Importing libraries
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline

# to handle missing data
from sklearn.impute import KNNImputer
from sklearn.impute import SimpleImputer

# for handling categorical data
from sklearn.preprocessing import LabelBinarizer 
from sklearn.preprocessing import LabelEncoder 

# for seperating testing and training data
from sklearn.model_selection import train_test_split

# scaling the dataset
from sklearn.preprocessing import MinMaxScaler

# decision tree
from sklearn.tree import DecisionTreeClassifier

# for confusion matrix
from sklearn.metrics import accuracy_score,confusion_matrix,classification_report

# for random forest
from sklearn.ensemble import RandomForestClassifier

# for Support Vector Machine
from sklearn.svm import SVC

# for Logistic Regression
from sklearn.linear_model import LogisticRegression

# for storing the trained model as a pickle file
import pickle

"""#Functions to imporve visualization"""

def resizePlot():
  plt.figure(figsize=(12,6))

def resizecolor():
  plt.figure(figsize=(15,7))

"""# Loading the dataset"""

df = pd.read_csv("/Weather1.csv")

df.head()

"""# Handling Missing data

## Checking the existence of missing data
"""

df.isnull().sum()

"""## Visualizing missing data"""

resizePlot()
sns.heatmap(df.isnull(), yticklabels=False, cbar=False, cmap='viridis')

"""# Plotting HeatMap to derive hidden correlations bw the columns of the dataset"""

resizecolor()
sns.heatmap(df.corr(),annot=True)

"""# Finding the correlation bw variables and their dependency and drawing conclusions

**Highest correlation exists bw MinTemp & Temp9am**
"""

sns.relplot(x='MinTemp', y='Temp9am', data = df)

"""**Plotting same graph as above for MaxTemp & Temp3pm**"""

sns.relplot(x='MaxTemp', y='Temp9am', data = df)

"""# Converting Categorical Data to Numeric Data"""

le = LabelEncoder()

df['RainToday'] = le.fit_transform(df['RainToday'])

df.head()

"""# Training and Testing of ml algo

**Splitting the input and output variables**
"""

x = df.drop('RainToday',axis=1).values
y = df['RainToday'].values

"""**Scaling the data**"""

# minMax = MinMaxScaler()
# x = minMax.fit_transform(x)

"""**Seperating the training and testing data**"""

X_train, X_test, y_train, y_test = train_test_split(x, y, test_size=0.33, random_state=101)

"""## Applying Algorithms

### Decision Tree
"""

dtree = DecisionTreeClassifier()

dtree.fit(X_train,y_train)


# storing the trained model as a pickel file
with open("decisionTree.pkl","wb") as f:
  pickle.dump(dtree, f)

previsor_dtree = dtree.predict(X_test)

print(classification_report(y_test,previsor_dtree))
print(confusion_matrix(y_test,previsor_dtree))
print('\n')
print('Accuracy:',np.round(accuracy_score(y_test,previsor_dtree),3)*100,'%')

"""### Random Forest"""

rfc = RandomForestClassifier(n_estimators=500)

rfc.fit(X_train,y_train)
# storing the trained model as a pickel file
with open("randomForest.pkl","wb") as f:
  pickle.dump(rfc, f)

previsor_rfc = rfc.predict(X_test)

print(classification_report(y_test,previsor_rfc))
print(confusion_matrix(y_test,previsor_rfc))
print('\n')
print('Acur√°cia:',np.round(accuracy_score(y_test,previsor_rfc),3)*100,'%')

"""### Support Vector Machine"""

svc = SVC()

svc.fit(X_train, y_train)
# storing the trained model as a pickel file
with open("svm.pkl","wb") as f:
  pickle.dump(svc, f)

previsor_svc = svc.predict(X_test)

print(classification_report(y_test,previsor_svc))
print(confusion_matrix(y_test,previsor_svc))
print('\n')
print('Accuracy:',np.round(accuracy_score(y_test,previsor_svc),3)*100,'%')

"""### Logistic Regression"""

LR = LogisticRegression()

LR.fit(X_train,y_train)
# storing the trained model as a pickel file
with open("logistic.pkl","wb") as f:
  pickle.dump(LR, f)

predict_LR = LR.predict(X_test)

print(classification_report(y_test,predict_LR))
print(confusion_matrix(y_test,predict_LR))
print('\n')
print('Accuracy:', np.round(accuracy_score(y_test,predict_LR),3)*100,'%')

"""### Concluding the output from all algos"""

Accuracy_LR = np.round(accuracy_score(y_test,predict_LR),3) *100
Accuracy_svc = np.round(accuracy_score(y_test,previsor_svc),3)*100
Accuracy_rfc = np.round(accuracy_score(y_test,previsor_rfc),3)*100
Accuracy_dtree = np.round(accuracy_score(y_test,previsor_dtree),3)*100

print('Accuracy_Decision_tree: ',Accuracy_dtree,'%')
print('Accuracy_Random_Forest: ', Accuracy_rfc,'%')
print('Accuracy_LR: ', Accuracy_LR,'%')
print('Accuracy_SVC: ', Accuracy_svc,'%')

"""# We then had a better assessment of our Logistic Regression and Support Vector Machine with an 86.8% chance of not raining with this information

# Defining Functions to call the model and give the predicted value as output

## Decision Tree

Creating the function to open the pickle file and predict the output based upon the given inputs
"""

def decisionTreePrediction(MinTemp, MaxTemp, Humidity9am, Humidity3pm, Temp9am, Temp3pm):
  with open("decisionTree.pkl", "rb") as f:
    dTreeF = pickle.load(f)
    preds = dTreeF.predict([[MinTemp, MaxTemp, Humidity9am, Humidity3pm, Temp9am, Temp3pm]])

    if(preds == 1):
      return "Rain Tomorrow"
    else:
      return "No Rain Tomo"

"""## Random Forest

Creating the function to open the pickle file and predict the output based upon the given inputs
"""

def randomForestPrediction(MinTemp, MaxTemp, Humidity9am, Humidity3pm, Temp9am, Temp3pm):
  with open("randomForest.pkl", "rb") as f:
    rfcF = pickle.load(f)
    preds = rfcF.predict([[MinTemp, MaxTemp, Humidity9am, Humidity3pm, Temp9am, Temp3pm]])

    if(preds == 1):
      return "Rain Tomorrow"
    else:
      return "No Rain Tomorrow"

"""## Support Vector Machine

Creating the function to open the pickle file and predict the output based upon the given inputs
"""

def SVMPrediction(MinTemp, MaxTemp, Humidity9am, Humidity3pm, Temp9am, Temp3pm):
  with open("svm.pkl", "rb") as f:
    svmF = pickle.load(f)
    preds = svmF.predict([[MinTemp, MaxTemp, Humidity9am, Humidity3pm, Temp9am, Temp3pm]])

    if(preds == 1):
      return "Rain Tomorrow"
    else:
      return "No Rain Tomorrow"

"""## Logistic Regression

Creating the function to open the pickle file and predict the output based upon the given inputs
"""

def LRPrediction(MinTemp, MaxTemp, Humidity9am, Humidity3pm, Temp9am, Temp3pm):
  with open("logistic.pkl", "rb") as f:
    LRF = pickle.load(f)
    preds = LRF.predict([[MinTemp, MaxTemp, Humidity9am, Humidity3pm, Temp9am, Temp3pm]])

    if(preds == 1):
      return "Rain Tomorrow"
    else:
      return "No Rain Tomorrow"

